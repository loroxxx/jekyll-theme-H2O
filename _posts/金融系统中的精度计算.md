---
layout: post
title: '金融系统中的精度计算'
subtitle: '金融系统中的精度计算'
date: 2017-05-18
categories: 技术
cover: ''
tags: 金融系统 精度 设计
---

## # 金融系统中的精度计算

**先说结论，不推荐使用浮点数计算，float和double只能用来做科学计算或者是工程计算，在金融系统中中我们要用String构造.BigDecimal来计算**


那么我们在商业计算中，为什么不推荐浮点数计算呢，并不是说浮点数float/double的精度不够，64位的系统中，float类型可以表示小数点后11位，double类型更多，对于这样的精度，任何金融系统都是足够了。之所以不推荐使用浮点类型，那就要先从操作系统浮点类型的表示方法来说起了。我们都知道，计算机中存储整数是采用二进制，十进制转化成二进制的

```css
先看下面的代码：

System.out.println(0.05 + 0.01 - 0.06);
输出的结果是：6.938893903907228E-18


我们可以再构造一些浮点数之间的计算：
        System.out.println(0.15+0.01);
        System.out.println(1.0-0.42);
        System.out.println(4.0255*1000);
        System.out.println(123.52/100);
        System.out.println(1/3 * 3);
        System.out.println(0.1+0.2);
        
输出的结果是：
0.16
0.5800000000000001
401.49999999999994
1.2351999999999999
0
0.30000000000000004

```
得到的结果有一些反直觉，但这在计算机中属于正常，不光是Java语言，在其它很多编程语言中也有这样的问题，这个问题有时候相当严重，如果用来判断条件，你有9.999999999999元，但是你的计算机是不会认为你可以购买10元的商品的。

#### 问题原因

为什么会出现这个问题：

比方说，我们要计算0.3 * 2，我们输入的"0.3"是十进制的，
计算机要先把浮点数0.3转换为二进制：0.0100110011001100110011001100110011001100110011001101

但是当我们把这个二进制再转换为十进制显示的时候得到的是：0.30000000000000004

也就是说0.3用二进制法无法准确表示，如果转换为二进制后浮点数参与了计算，那么计算的结果也不会准确。至于为什么有些浮点计算会得到准确的结果，应该也是碰巧那个计算的二进制与十进制之间能够准确转换。


我们再举个例子：

```css
public class Demo {
 public static void main(String[] args) {
   double x = 10.00;
   double y = 9.60;
   double z = x - y;
   System.out.println(z);
 }
}

直观来讲大多数会觉得应该返回0.4，而真是的结果是：
0.40000000000000036
```

其实真正的误差很小，在金融系统里面本身也不要求这么高的精度，做一些精度的四舍五入之后，数据的准确性完全满足我们的要求，但是在对浮点类型数据做任何相等比较的时候，都需要引入误差范围，对于大于小于的比较则更加麻烦。
比如：

```css

if (Math.abs(f1-f2)<0.0001) {
 // f1 == f2
}
```

除此之外，金融系统中的数据舍入算法多种多样，并非单纯的四舍五入，有些是业务的需要，比如向上取整，向下取整，直接截取等。所以如果用浮点数来表金额数据，在某些取整算法下，会产生较大的误差。 


#### 正确使用

那么，我们怎么解决这个问题呢。

在基金系统计算收益中，我们规定金额全部使用整数表示，计算的时候也一样，比方说事先规定金额带两位小数点，那么10000其实表示的是100.00。我们在计算的时候，都会按10000来计算，只有在显示结果时，再乘以0.01.这样就可以避免上面出现的问题。


而更广泛的解决方法是金额一般都用BigDecimal，BigDecimal将数据分两部分存储：整数部分+小数部分，小数部分也是通过整型类型来表示的，所以就避免了浮点类型的问题。使用BigDecimal在数据表示，加减乘运算都不会产生任何误差。除法有可能会遇到除不尽的情况，需要指定rounding算法。

BigDecimal将数据分两部分存储：整数部分+小数部分，小数部分也是通过整型类型来表示的，所以就避免了浮点类型的问题。使用BigDecimal在数据表示，加减乘运算都不会产生任何误差。除法有可能会遇到除不尽的情况，需要指定rounding算法。


#### 注意事项

在使用BigDecimal的时候，有几个注意事项：

##### 1. 使用String入参的构造函数，不要使用浮点数作为入参的构造函数。

```css
比如
BigDecimal b = new BigDecimal(0.1);
System.out.println(b.toString());

打印出来的结果：
0.1000000000000000055511151231257827021181583404541015625
原因是0.1在传入BigDecimal之前已经是不准确的了。
正确的使用方法应该是：
BigDecimal b = new BigDecimal(“0.1”);

```

##### 2. 谨慎使用除法divide()方法

比如如下代码：

```css
    BigDecimal a = new BigDecimal("1.0");
    BigDecimal b = new BigDecimal("3.0");
    BigDecimal c = a.divide(b);

    运行会抛出exception：java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.

    所以在使用除法方法是要考虑能否除尽，如果存在除不尽的情况，需要使用另一个方法指定舍入精度，如下：
    BigDecimal c = a.divide(b, 2, BigDecimal.ROUND_HALF_EVEN);

```



##### 3.另外还要注意下数据库Mysql和Oracle的存储方法

Mysql中Decimal和Oracle里面的Number经常用来存储金额数据，高精度无误差，比如Decimal(7,3)和Number(7,3)，其中7表示数据位数，包括小数点前后，3表示小数点之后的数据位数。如果存储的数据超出了精度，比如存入43.3445，Mysql会四舍五入，Oracle会直接截断。
所以为了避免产生不可预测的结果，在存入数据库之前最好按精度要求rounding好，以免触发数据库rounding。从数据库取出数据时，也要用BigDecimal来映射，避免浮点数表示的准确性问题。


##### 4. 在金融系统里面，精度保留几位以及如何取舍.

并没有一个标准的准则，一般都是根据业务的需要，具体问题具体分析。
一般情况，存储在数据库中的数据小数点后要尽量多保留几位，不要依赖数据库的Rounding，具体几位根据业务情况来决定。对于计算中间结果，最好尽量多保留几位，在存入数据库或者展示给用户时再按照业务需要做rounding。比如数据库中保留5位小数，计算过程保留8位，展示给用户保留2位到分即可。



### java.math.RoundingMode 几个参数详解

上面讲了BigDecimal类型能精确表示和计算，但并不是说明就不存在在精度rounding问题了。虽然在计算过程中我们可以尽量的保留精度，但由于存储，显示以及一些具体的业务需要，都会涉及到rounding算法。



现以个人理解对其一一进行总结：
- RoundingMode.CEILING：取右边最近的整数
- RoundingMode.CEILING：取右边最近的整数
- RoundingMode.DOWN：去掉小数部分取整，也就是正数取左边，负数取右边，相当于向原点靠近的方向取整
- RoundingMode.FLOOR：取左边最近的正数
- RoundingMode.HALF_DOWN:五舍六入，负数先取绝对值再五舍六入再负数
- RoundingMode.HALF_UP:四舍五入，负数原理同上
- RoundingMode.HALF_EVEN:整数位若是奇数则四舍五入，若是偶数则五舍六入


##### Banker’s Rounding四舍六入五取双
在金融系统里面经常用到的舍入方法是四舍六入五成双，也叫做银行家舍入算法，此舍入算法是对四舍五入方法的改进，因为四舍五入方法在累计过程中会产生比较大的误差。
因为在累加误差的情况下，四舍五入方法无法将舍入误差完全抵消，比如0.01舍，会产生-0.01的误差，而0.09入，会抵消0.01产生的-0.01的误差，同样0.02和0.08，0.03和0.07，0.04和0.06，都可以正负误差相抵，而0.05会进一产生+0.05的误差无人抵消。

所以在数据分布比较平衡的情况下，对于sum加总操作，10次舍入就会产生一个0.05的误差，如果是100万次舍入操作，就会产生50000的误差
。
来看下银行家舍入如何改进四舍五入的：
舍去位的数值小于5时，直接舍去；舍去位的数值大于等于6时，进位后舍去；当舍去位的数值等于5时，分两种情况：5后面还有其他数字（非0），则进位后舍去；若5后面是0（即5是最后一个数字），则根据5前一位数的奇偶性来判断是否需要进位，偶数进位，奇数舍去
。以上规则汇总成一句话：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应进一，五前为奇要舍入。

当然银行家算法也不是适应用所有等情况，有时候还会根据业务需求选择其他舍入方法比，如分息向上取整，罚息向下取整，保证客户不亏。

